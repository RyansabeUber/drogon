/**
 *
 *  {{className}}.cc
 *  created by drogon_ctl
 *
 */
<%inc#include "create_model.h"
using namespace drogon_ctl;
%>

#include "{{className}}.h"
#include <string>
<%c++
    auto cols=@@.get<std::vector<ColumnInfo>>("columns");
    auto className=@@.get<std::string>("className");
%>

using namespace drogon_model::{{dbName}};

<%c++for(auto col:cols){
%>
const std::string {{className}}::Cols::<%c++$$<<col._colName;%> = "<%c++$$<<col._colName;%>";
<%c++
}%>

const std::string {{className}}::primaryKeyName = "{{primaryKeyName}}";
<%c++ if(@@.get<bool>("hasPrimaryKey",false)){%>
const bool {{className}}::hasPrimaryKey = true;
<%c++ }else{%>
const bool {{className}}::hasPrimaryKey = false;
<%c++}%>
const std::string {{className}}::tableName = "{{tableName}}";

const std::vector<typename {{className}}::MetaData> {{className}}::_metaData={
<%c++for(int i=0;i<cols.size();i++){
    auto &col=cols[i];
$$<<"{\""<<col._colName<<"\",\""<<col._colType<<"\","<<col._colLength<<","<<col._isAutoVal<<","<<col._isPrimaryKey<<","<<col._notNull<<"}";
if(i<(cols.size()-1))
$$<<",\n";
else
$$<<"\n";
}%>
};
const std::string &{{className}}::getColumnName(int index) noexcept(false)
{
    assert(index < _metaData.size());
    return _metaData[index]._colName;
}
{{className}}::{{className}}(const Row &r) noexcept
{
<%c++
    for(auto col:cols)
    {
        if(col._colType.empty())
            continue;
        %>
        if(!r["<%c++$$<<col._colName;%>"].isNull())
        {
            _<%c++$$<<col._colValName;%>=std::make_shared<<%c++$$<<col._colType;%>>(r["<%c++$$<<col._colName;%>"].as<<%c++$$<<col._colType;%>>());
        }
<%c++
    }
    %>
}
<%c++
    for(int i=0;i<cols.size();i++)
    {
        auto & col = cols[i];
        if(!col._colType.empty())
        {
            $$<<"const "<<col._colType<<" & "<<className<<"::getValueOf"<<col._colTypeName<<"(const "<<col._colType<<" &defaultValue) const noexcept\n";
            $$<<"{\n";
            $$<<"    if(_"<<col._colValName<<")\n";
            $$<<"        return *_"<<col._colValName<<";\n";
            $$<<"    return defaultValue;\n";
            $$<<"}\n";
          
            $$<<"std::shared_ptr<const "<<col._colType<<"> "<<className<<"::get"<<col._colTypeName<<"() const noexcept\n";
            $$<<"{\n";
            $$<<"    return _"<<col._colValName<<";\n";
            $$<<"}\n";
 
            if(!col._isAutoVal)
            {
                $$<<"void "<<className<<"::set"<<col._colTypeName<<"(const "<<col._colType<<" &"<<col._colValName<<") noexcept\n";
                $$<<"{\n";
                $$<<"    _"<<col._colValName<<" = std::make_shared<"<<col._colType<<">("<<col._colValName<<");\n";
                $$<<"    _dirtyFlag["<<i<<"] = true;\n";
                $$<<"}\n";
                
                if(col._colType=="std::string")
                {
                    $$<<"void "<<className<<"::set"<<col._colTypeName<<"("<<col._colType<<" &&"<<col._colValName<<") noexcept\n";
                    $$<<"{\n";
                    $$<<"    _"<<col._colValName<<" = std::make_shared<"<<col._colType<<">(std::move("<<col._colValName<<"));\n";
                    $$<<"    _dirtyFlag["<<i<<"] = true;\n";
                    $$<<"}\n";
                }
            }
            if(col._isPrimaryKey)
            {
                $$<<"const typename "<<className<<"::PrimaryKeyType & "<<className<<"::getPrimaryKey() const\n";
                $$<<"{\n";
                $$<<"    assert(_"<<col._colValName<<");\n";
                $$<<"    return *_"<<col._colValName<<";\n";
                $$<<"}\n";
            }
        }
        $$<<"\n";    
    }
%>

const std::vector<std::string> &{{className}}::insertColumns() noexcept
{
    static const std::vector<std::string> _inCols={
<%c++for(int i=0;i<cols.size();i++){
    auto col=cols[i];
    if(!col._isAutoVal&&!col._colType.empty())
    {
        $$<<"        \""<<col._colName<<"\"";
        if(i<(cols.size()-1))
            $$<<",\n";
        else
            $$<<"\n";
    }
}%>
    };
    return _inCols;
}

void {{className}}::outputArgs(drogon::orm::internal::SqlBinder &binder) const
{
<%c++for(auto col:cols){
    if(!col._isAutoVal&&!col._colType.empty())
    {
%>
    if(get<%c++$$<<col._colTypeName;%>())
    {
        binder << getValueOf<%c++$$<<col._colTypeName;%>();
    }
    else
    {
        binder << nullptr;
    }
<%c++
    }
}
%>
}

const std::vector<std::string> {{className}}::updateColumns() const
{
    std::vector<std::string> ret;
    for(int i=0;i<sizeof(_dirtyFlag);i++)
    {
        if(_dirtyFlag[i])
        {
            ret.push_back(getColumnName(i));
        }
    }
    return ret;
}

void {{className}}::updateArgs(drogon::orm::internal::SqlBinder &binder) const
{
<%c++
    for(int i=0;i<cols.size();i++)
    {
        auto & col=cols[i];
        if(col._colType.empty()||col._isAutoVal)
            continue;
%>
    if(_dirtyFlag[<%c++$$<<i;%>])
    {
        if(get<%c++$$<<col._colTypeName;%>())
        {
            binder << getValueOf<%c++$$<<col._colTypeName;%>();
        }
        else
        {
            binder << nullptr;
        }
    }
<%c++
    }
%>
}